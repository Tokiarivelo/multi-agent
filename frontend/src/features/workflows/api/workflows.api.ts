import { apiClient } from '@/lib/api-client';
import { Workflow, PaginatedResponse } from '@/types';

export interface WorkflowExecution {
  id: string;
  workflowId: string;
  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
  input?: Record<string, unknown>;
  output?: Record<string, unknown>;
  error?: string;
  nodeExecutions: NodeExecution[];
  currentNodeId?: string;
  startedAt?: string;
  completedAt?: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface NodeExecution {
  nodeId: string;
  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'SKIPPED';
  input?: unknown;
  output?: unknown;
  error?: string;
  startedAt?: string;
  completedAt?: string;
  retryCount: number;
}

export interface AddNodePayload {
  id: string;
  type:
    | 'AGENT'
    | 'TOOL'
    | 'CONDITIONAL'
    | 'TRANSFORM'
    | 'START'
    | 'END'
    | 'PROMPT'
    | 'TEXT'
    | 'FILE';
  customName?: string;
  config?: Record<string, unknown>;
  position?: { x: number; y: number };
}

export interface AddEdgePayload {
  id: string;
  source: string;
  target: string;
  condition?: string;
}

export const workflowsApi = {
  // ─── Workflow CRUD ────────────────────────────────────────────────

  getAll: async (page = 1, pageSize = 20): Promise<PaginatedResponse<Workflow>> => {
    const { data } = await apiClient.get<PaginatedResponse<Workflow>>(
      `/api/workflows?page=${page}&pageSize=${pageSize}`,
    );
    return data;
  },

  getById: async (id: string): Promise<Workflow> => {
    const { data } = await apiClient.get<Workflow>(`/api/workflows/${id}`);
    return data;
  },

  create: async (workflow: Partial<Workflow>): Promise<Workflow> => {
    const { data } = await apiClient.post<Workflow>('/api/workflows', workflow);
    return data;
  },

  update: async (id: string, workflow: Partial<Workflow>): Promise<Workflow> => {
    const { data } = await apiClient.put<Workflow>(`/api/workflows/${id}`, workflow);
    return data;
  },

  delete: async (id: string): Promise<void> => {
    await apiClient.delete(`/api/workflows/${id}`);
  },

  // ─── Node operations ──────────────────────────────────────────────

  addNode: async (workflowId: string, node: AddNodePayload): Promise<Workflow> => {
    const { data } = await apiClient.post<Workflow>(`/api/workflows/${workflowId}/nodes`, node);
    return data;
  },

  updateNode: async (
    workflowId: string,
    nodeId: string,
    node: Partial<AddNodePayload>,
  ): Promise<Workflow> => {
    const payload = { ...node };
    delete payload.id;

    const { data } = await apiClient.put<Workflow>(
      `/api/workflows/${workflowId}/nodes/${nodeId}`,
      payload,
    );
    return data;
  },

  deleteNode: async (workflowId: string, nodeId: string): Promise<void> => {
    await apiClient.delete(`/api/workflows/${workflowId}/nodes/${nodeId}`);
  },

  // ─── Edge operations ──────────────────────────────────────────────

  addEdge: async (workflowId: string, edge: AddEdgePayload): Promise<Workflow> => {
    const { data } = await apiClient.post<Workflow>(`/api/workflows/${workflowId}/edges`, edge);
    return data;
  },

  deleteEdge: async (workflowId: string, edgeId: string): Promise<void> => {
    await apiClient.delete(`/api/workflows/${workflowId}/edges/${edgeId}`);
  },

  // ─── Execution ────────────────────────────────────────────────────

  execute: async (id: string, input?: Record<string, unknown>): Promise<WorkflowExecution> => {
    const { data } = await apiClient.post<WorkflowExecution>(`/api/workflows/${id}/execute`, {
      input,
    });
    return data;
  },

  getExecution: async (executionId: string): Promise<WorkflowExecution> => {
    const { data } = await apiClient.get<WorkflowExecution>(
      `/api/workflows/executions/${executionId}`,
    );
    return data;
  },

  cancelExecution: async (executionId: string): Promise<void> => {
    await apiClient.post(`/api/workflows/executions/${executionId}/cancel`);
  },

  resumeNode: async (executionId: string, nodeId: string, input: string): Promise<void> => {
    await apiClient.post(`/api/workflows/executions/${executionId}/nodes/${nodeId}/resume`, {
      input,
    });
  },

  // ─── Files ────────────────────────────────────────────────────────

  uploadFile: async (
    file: File,
  ): Promise<{ id: string; key: string; storedName: string; url?: string }> => {
    // 1. Initiate upload to get a pre-signed url from MinIO
    const { data: initData } = await apiClient.post<{
      uploadUrl: string;
      record: { id: string; key: string; storedName: string; url?: string };
    }>('/api/files/initiate-upload', {
      originalName: file.name,
      mimeType: file.type || 'application/octet-stream',
      size: file.size,
    });

    // 2. Upload file directly to MinIO
    let presignedUrl = initData.uploadUrl;
    // In local development, the presigned url generated by the backend
    // might point to internally routed "minio" but the browser only resolves localhost
    if (presignedUrl.includes('://minio:')) {
      presignedUrl = presignedUrl.replace('://minio:', '://localhost:');
    }

    const response = await fetch(presignedUrl, {
      method: 'PUT',
      body: file,
      headers: {
        'Content-Type': file.type || 'application/octet-stream',
      },
      // Note: MinIO requires these headers correctly or pre-flight CORS might fail
    });

    if (!response.ok) {
      throw new Error(`Direct MinIO upload failed: ${response.statusText}`);
    }

    if (initData.record.url && initData.record.url.includes('://minio:')) {
      initData.record.url = initData.record.url.replace('://minio:', '://localhost:');
    }

    return initData.record;
  },

  getFileUrl: async (fileId: string): Promise<{ url: string }> => {
    const { data } = await apiClient.get<{ url: string }>(`/api/files/${fileId}/url`);
    return data;
  },
};
